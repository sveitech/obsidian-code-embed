/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CodeEmbed
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  mySetting: "default"
};
var CodeEmbed = class extends import_obsidian.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.registerMarkdownCodeBlockProcessor("codefile", (source, el, ctx) => __async(this, null, function* () {
        const { vault } = this.app;
        const rows = source.split("\n").filter((row) => row.length > 0);
        if (rows.length == 0) {
          return;
        }
        ;
        const tokens = rows[0].split(":");
        let filename = "";
        let language = "";
        if (tokens.length == 1) {
          filename = tokens[0];
        } else if (tokens.length == 2) {
          language = tokens[0];
          filename = tokens[1];
        }
        const file = vault.getAbstractFileByPath(filename);
        if (file != null) {
          const fileContents = yield vault.cachedRead(file);
          let markdown = "```" + language;
          markdown += "\r\n";
          markdown += fileContents;
          markdown += "```";
          import_obsidian.MarkdownRenderer.renderMarkdown(markdown, el, "", null);
        } else {
          el.innerText = "Could not load file " + filename;
        }
      }));
      this.addSettingTab(new SampleSettingTab(this.app, this));
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
var SampleSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for my awesome plugin." });
    new import_obsidian.Setting(containerEl).setName("Setting #1").setDesc("It's a secret").addText((text) => text.setPlaceholder("Enter your secret").setValue(this.plugin.settings.mySetting).onChange((value) => __async(this, null, function* () {
      console.log("Secret: " + value);
      this.plugin.settings.mySetting = value;
      yield this.plugin.saveSettings();
    })));
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIE1hcmtkb3duVmlldywgTW9kYWwsIE5vdGljZSwgUGx1Z2luLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nLCBNYXJrZG93blJlbmRlcmVyIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG4vLyBSZW1lbWJlciB0byByZW5hbWUgdGhlc2UgY2xhc3NlcyBhbmQgaW50ZXJmYWNlcyFcblxuaW50ZXJmYWNlIENvZGVFbWJlZFNldHRpbmdzIHtcblx0bXlTZXR0aW5nOiBzdHJpbmc7XG59XG5cbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IENvZGVFbWJlZFNldHRpbmdzID0ge1xuXHRteVNldHRpbmc6ICdkZWZhdWx0J1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2RlRW1iZWQgZXh0ZW5kcyBQbHVnaW4ge1xuXHRzZXR0aW5nczogQ29kZUVtYmVkU2V0dGluZ3M7XG5cblx0YXN5bmMgb25sb2FkKCkge1xuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyTWFya2Rvd25Db2RlQmxvY2tQcm9jZXNzb3IoXCJjb2RlZmlsZVwiLCBhc3luYyAoc291cmNlLCBlbCwgY3R4KSA9PiB7XG5cdFx0XHRjb25zdCB7IHZhdWx0IH0gPSB0aGlzLmFwcDtcblx0XHRcdGNvbnN0IHJvd3MgPSBzb3VyY2Uuc3BsaXQoXCJcXG5cIikuZmlsdGVyKChyb3cpID0+IHJvdy5sZW5ndGggPiAwKTtcblx0XHRcdFxuXHRcdFx0aWYgKHJvd3MubGVuZ3RoID09IDApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3QgdG9rZW5zID0gcm93c1swXS5zcGxpdChcIjpcIik7XG5cdFx0XHRsZXQgZmlsZW5hbWUgPSBcIlwiXG5cdFx0XHRsZXQgbGFuZ3VhZ2UgPSBcIlwiXG5cblx0XHRcdGlmICh0b2tlbnMubGVuZ3RoID09IDEpIHtcblx0XHRcdFx0ZmlsZW5hbWUgPSB0b2tlbnNbMF07XG5cdFx0XHR9IGVsc2UgaWYodG9rZW5zLmxlbmd0aCA9PSAyKSB7XG5cdFx0XHRcdGxhbmd1YWdlID0gdG9rZW5zWzBdO1xuXHRcdFx0XHRmaWxlbmFtZSA9IHRva2Vuc1sxXTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y29uc3QgZmlsZSA9IHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmaWxlbmFtZSk7XG5cblx0XHRcdGlmIChmaWxlICE9IG51bGwpIHtcblx0XHRcdFx0Y29uc3QgZmlsZUNvbnRlbnRzID0gYXdhaXQgdmF1bHQuY2FjaGVkUmVhZChmaWxlKTtcblxuXHRcdFx0XHRsZXQgbWFya2Rvd24gPSBcImBgYFwiICsgbGFuZ3VhZ2U7XG5cdFx0XHRcdG1hcmtkb3duICs9IFwiXFxyXFxuXCI7XG5cdFx0XHRcdG1hcmtkb3duICs9IGZpbGVDb250ZW50cztcblx0XHRcdFx0bWFya2Rvd24gKz0gXCJgYGBcIjtcblxuXHRcdFx0XHRNYXJrZG93blJlbmRlcmVyLnJlbmRlck1hcmtkb3duKG1hcmtkb3duLCBlbCwgXCJcIiwgbnVsbCk7XG5cdFx0XHRcdC8vY29kZS5pbm5lclRleHQgPSBmaWxlQ29udGVudHM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbC5pbm5lclRleHQgPSBcIkNvdWxkIG5vdCBsb2FkIGZpbGUgXCIgKyBmaWxlbmFtZTtcblx0XHRcdH1cblx0XHQgIH0pO1xuXG5cdFx0Ly8gVGhpcyBhZGRzIGEgc2V0dGluZ3MgdGFiIHNvIHRoZSB1c2VyIGNhbiBjb25maWd1cmUgdmFyaW91cyBhc3BlY3RzIG9mIHRoZSBwbHVnaW5cblx0XHR0aGlzLmFkZFNldHRpbmdUYWIobmV3IFNhbXBsZVNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcblx0fVxuXG5cdG9udW5sb2FkKCkge1xuXG5cdH1cblxuXHRhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG5cdFx0dGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSk7XG5cdH1cblxuXHRhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG5cdFx0YXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcblx0fVxufVxuXG5jbGFzcyBTYW1wbGVNb2RhbCBleHRlbmRzIE1vZGFsIHtcblx0Y29uc3RydWN0b3IoYXBwOiBBcHApIHtcblx0XHRzdXBlcihhcHApO1xuXHR9XG5cblx0b25PcGVuKCkge1xuXHRcdGNvbnN0IHtjb250ZW50RWx9ID0gdGhpcztcblx0XHRjb250ZW50RWwuc2V0VGV4dCgnV29haCEnKTtcblx0fVxuXG5cdG9uQ2xvc2UoKSB7XG5cdFx0Y29uc3Qge2NvbnRlbnRFbH0gPSB0aGlzO1xuXHRcdGNvbnRlbnRFbC5lbXB0eSgpO1xuXHR9XG59XG5cbmNsYXNzIFNhbXBsZVNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcblx0cGx1Z2luOiBDb2RlRW1iZWQ7XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogQ29kZUVtYmVkKSB7XG5cdFx0c3VwZXIoYXBwLCBwbHVnaW4pO1xuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xuXHR9XG5cblx0ZGlzcGxheSgpOiB2b2lkIHtcblx0XHRjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpcztcblxuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7dGV4dDogJ1NldHRpbmdzIGZvciBteSBhd2Vzb21lIHBsdWdpbi4nfSk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdTZXR0aW5nICMxJylcblx0XHRcdC5zZXREZXNjKCdJdFxcJ3MgYSBzZWNyZXQnKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignRW50ZXIgeW91ciBzZWNyZXQnKVxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubXlTZXR0aW5nKVxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ1NlY3JldDogJyArIHZhbHVlKTtcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5teVNldHRpbmcgPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0fSkpO1xuXHR9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBOEc7QUFROUcsSUFBTSxtQkFBc0M7QUFBQSxFQUMzQyxXQUFXO0FBQ1o7QUFFQSxJQUFxQixZQUFyQixjQUF1Qyx1QkFBTztBQUFBLEVBRzdDLEFBQU0sU0FBUztBQUFBO0FBQ2QsWUFBTSxLQUFLLGFBQWE7QUFFeEIsV0FBSyxtQ0FBbUMsWUFBWSxDQUFPLFFBQVEsSUFBSSxRQUFRO0FBQzlFLGNBQU0sRUFBRSxVQUFVLEtBQUs7QUFDdkIsY0FBTSxPQUFPLE9BQU8sTUFBTSxJQUFJLEVBQUUsT0FBTyxDQUFDLFFBQVEsSUFBSSxTQUFTLENBQUM7QUFFOUQsWUFBSSxLQUFLLFVBQVUsR0FBRztBQUNyQjtBQUFBLFFBQ0Q7QUFBQztBQUVELGNBQU0sU0FBUyxLQUFLLEdBQUcsTUFBTSxHQUFHO0FBQ2hDLFlBQUksV0FBVztBQUNmLFlBQUksV0FBVztBQUVmLFlBQUksT0FBTyxVQUFVLEdBQUc7QUFDdkIscUJBQVcsT0FBTztBQUFBLFFBQ25CLFdBQVUsT0FBTyxVQUFVLEdBQUc7QUFDN0IscUJBQVcsT0FBTztBQUNsQixxQkFBVyxPQUFPO0FBQUEsUUFDbkI7QUFFQSxjQUFNLE9BQU8sTUFBTSxzQkFBc0IsUUFBUTtBQUVqRCxZQUFJLFFBQVEsTUFBTTtBQUNqQixnQkFBTSxlQUFlLE1BQU0sTUFBTSxXQUFXLElBQUk7QUFFaEQsY0FBSSxXQUFXLFFBQVE7QUFDdkIsc0JBQVk7QUFDWixzQkFBWTtBQUNaLHNCQUFZO0FBRVosMkNBQWlCLGVBQWUsVUFBVSxJQUFJLElBQUksSUFBSTtBQUFBLFFBRXZELE9BQU87QUFDTixhQUFHLFlBQVkseUJBQXlCO0FBQUEsUUFDekM7QUFBQSxNQUNDLEVBQUM7QUFHSCxXQUFLLGNBQWMsSUFBSSxpQkFBaUIsS0FBSyxLQUFLLElBQUksQ0FBQztBQUFBLElBQ3hEO0FBQUE7QUFBQSxFQUVBLFdBQVc7QUFBQSxFQUVYO0FBQUEsRUFFQSxBQUFNLGVBQWU7QUFBQTtBQUNwQixXQUFLLFdBQVcsT0FBTyxPQUFPLENBQUMsR0FBRyxrQkFBa0IsTUFBTSxLQUFLLFNBQVMsQ0FBQztBQUFBLElBQzFFO0FBQUE7QUFBQSxFQUVBLEFBQU0sZUFBZTtBQUFBO0FBQ3BCLFlBQU0sS0FBSyxTQUFTLEtBQUssUUFBUTtBQUFBLElBQ2xDO0FBQUE7QUFDRDtBQWtCQSxJQUFNLG1CQUFOLGNBQStCLGlDQUFpQjtBQUFBLEVBRy9DLFlBQVksS0FBVSxRQUFtQjtBQUN4QyxVQUFNLEtBQUssTUFBTTtBQUNqQixTQUFLLFNBQVM7QUFBQSxFQUNmO0FBQUEsRUFFQSxVQUFnQjtBQUNmLFVBQU0sRUFBQyxnQkFBZTtBQUV0QixnQkFBWSxNQUFNO0FBRWxCLGdCQUFZLFNBQVMsTUFBTSxFQUFDLE1BQU0sa0NBQWlDLENBQUM7QUFFcEUsUUFBSSx3QkFBUSxXQUFXLEVBQ3JCLFFBQVEsWUFBWSxFQUNwQixRQUFRLGVBQWdCLEVBQ3hCLFFBQVEsVUFBUSxLQUNmLGVBQWUsbUJBQW1CLEVBQ2xDLFNBQVMsS0FBSyxPQUFPLFNBQVMsU0FBUyxFQUN2QyxTQUFTLENBQU8sVUFBVTtBQUMxQixjQUFRLElBQUksYUFBYSxLQUFLO0FBQzlCLFdBQUssT0FBTyxTQUFTLFlBQVk7QUFDakMsWUFBTSxLQUFLLE9BQU8sYUFBYTtBQUFBLElBQ2hDLEVBQUMsQ0FBQztBQUFBLEVBQ0w7QUFDRDsiLAogICJuYW1lcyI6IFtdCn0K
